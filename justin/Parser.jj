/* Ethan Petuchowski    EID: ecp456     CSID: ethanp    */

PARSER_BEGIN(Parser)

/** An Arithmetic Grammar. */
public class Eg1 {

  /** Main entry point. */
  public static void main(String args[]) {
    System.out.println("Reading from standard input...");
    Parser t = new Parser(System.in);
    try {
      SimpleNode n = t.Start();
      n.dump("");
      System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
}
   
PARSER_END(Parser)

SKIP:
{
    " "
  | "\t"
  | "\n"
  | "\r"
  | <"%" (~["\n","\r"])* ("\n"|"\r")>
}

TOKEN:
{
    < LAMBDA : "lambda" >
  | < LET    : "let"    >
}

TOKEN:
{
    < LPAR : "(" >
  | < RPAR : ")" >
  | < NUMBER : (["-"])? (["0"-"9"])+ ("." (["0"-"9"])+)?
              |(["-"])? "." (["0"-"9"])+ >
  | < OP:    ["-", "+", "*", "/"] >
  | < SYMBOL : ["a"-"z", "A"-"Z", "~", "`", "!", "@", "#", "$", "/", "^", "&",
                "*", "_", "-", "=", "+", "{", "}", "[", "]", "|", "\\", ":",
                ";", "<", ">", ",", ".", "?", "'", "\""](["a"-"z", "A"-"Z",
                "0"-"9", "~", "`", "!", "@", "#", "$", "/", "^", "&", "*", "_",
                "-", "=", "+", "{", "}", "[", "]", "|", "\\", ":", ";", "<",
                ">", ",", ".", "?", "'", "\""])* >


}

TOKEN:
{
  < ERROR : ~[] >
}

/*
Atom atom():
{ Token n; }
{
    n = <NUMBER> { return new CronoNumber(Long.valueOf(n.image)); }
  | n = <SYMBOL>      { return Symbol.valueOf(n.image); }
}

Cons list():
{
  Atom a;
  Cons c;
  List<CronoType> l = new ArrayList<CronoType>();
}
{ <LET> {} }
*/

void output() :
{ Token n; }
{
    <LET>       { System.out.print("let "); output(); }
  | <EOF>       { System.out.print("eof \n"); }
  | <NUMBER>    { System.out.print("num "); output(); }
  | <LPAR>      { System.out.print("lpr "); output(); }
  | <RPAR>      { System.out.print("rpr "); output(); }
  | <SYMBOL>    { System.out.print("sym "); output(); }
  | <LAMBDA>    { System.out.print("lam "); output(); }
  | <OP>        { System.out.print("op "); output(); }
}


String javaLambda() :
{ Token n; String v; }
{ {return "";}
}


/** Main production. */
SimpleNode Start() : {}
{
  Expression() ";"
  { return jjtThis; }
}

SExpr expr() :
{
  Token n; 
  String v;
  SExpr s;
  SExpr s2;
  int i;
}
{
    LOOKAHEAD(2)
    /* Case: Lambda Expression */
        <LPAR>
        <LPAR>
        <LAMBDA>
        <LPAR>
    v = parameter() { SymbolAtom symAtom = new SymbolAtom(v); }
        <RPAR>
    s = body()
        <RPAR>
    s2 = body()
        <RPAR>   {
                    FunctionExpr function = new FunctionExpr(symAtom, s, s2);
                    SExpr evaluated = function.getBody();
                    System.out.println(evaluated);
                    return evaluated;
                 }
|   /* Case: just a number */
    n = <NUMBER> {  i = Integer.parseInt(n.toString()); return null; }

|   /* Case: just an Expr, e.g. (+ 3 3) */
    s = body() { System.out.println(((Expr)(s)).eval()); return s; }


| <EOF> {return null;}

}

SExpr body() :
{ Token n; String v; SExpr s; int i; }
{

    /* Case: body = SYMBOL */
    n = <SYMBOL>{ v = n.toString(); s = new SymbolAtom(v); return s; }

|   n = <NUMBER>{ i = Integer.parseInt(n.toString()); s = new NumericAtom(i); return s; }

|   /* Generalize Case 2: body = something like (+ x (+ x x)) OR (+ x x) */
    LOOKAHEAD(2)
        <LPAR>
    n = <OP>    { v = n.toString(); Expr e = new Expr(new StringAtom(v)); }

    (s = body()  { e.AddArg(s); })+
    <RPAR> { return e; }
|      LOOKAHEAD(2)
    /* Case: Lambda Expression */
        <LPAR>
        <LPAR>
        <LAMBDA>
        <LPAR>
    v = parameter() { SymbolAtom symAtom = new SymbolAtom(v); }
        <RPAR>
    s = body()
        <RPAR>
    n = <NUMBER> {  NumericAtom numAtom = new NumericAtom(Integer.parseInt(n.toString())); }
        <RPAR>   {
                    FunctionExpr function = new FunctionExpr(symAtom, s, numAtom);
                    SExpr evaluated = function.getBody();
                    System.out.println(evaluated);
                    return evaluated;
                 }
}


/* A Parameter for a Let or Lambda expr must be a <SYMBOL>
        This just converts that to a string */
String parameter() :
{
    Token n;
}
{
    n = <SYMBOL> { return n.toString(); }
}

String lambdaExpr() :
{
  Token n; 
  String v;
}
{
/* CASE : LET; current form: (let (( param  lambdaExpr )) lambdaExpr ) */
    LOOKAHEAD(2) <LPAR>
                 <LET>
                 <LPAR><LPAR>   { String A = "((lambda (" + parameter() + ") ";
                                  String B = lambdaExpr(); }
                 <RPAR><RPAR>   { String C = lambdaExpr(); }
                 <RPAR>         { A += C + ") " + B + ")"; return A; }

/* CASE : LAMBDA; current form: (lambda ( param ) lambdaExpr )*/
  | LOOKAHEAD(2) <LPAR>
                 <LAMBDA>
                 <LPAR>     { String A = "(lambda (" + parameter() + ") "; }
                 <RPAR>     { A += lambdaExpr() + ")"; }
                 <RPAR>     { return A; }


/* CASE : OPeration; current form: ( <OP> lambdaExpr (lambdaExpr)+ )
            E.g. (+ 3 3) ; (* 3 5 6 8); etc.            */
  | LOOKAHEAD(2) <LPAR>
             n = <OP>       { String B = "(" + n.toString() + " " + lambdaExpr(); }
           ( v = lambdaExpr()     { B += " " + v; }  )+
                 <RPAR>     { B += ")"; return B; }

/* CASE : Function Application; current form: ( (lambdaExpr)+ ) <== Warning: VERY GENERAL
            E.g. (F1 2 5) ; (23 ** 2| 3) <-Goes Through! */
  | LOOKAHEAD(2) <LPAR>
             v = lambdaExpr()     { String app = "(" + v; }
           ( v = lambdaExpr()     { app += " " + v; } )*
                 <RPAR>     { app += ")"; return app; }

/* CASE : NUMBER: could be Positive, Negative, Float, or Integer */
  |          n = <NUMBER>   { String B = n.toString(); return B; } 

/* CASE : SYMBOL: anything but Parentheses */
  |          n = <SYMBOL>   { String C = n.toString(); return C; }
}
