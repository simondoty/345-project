/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. LispParser.jj */
/*@egen*//*******************************************************************************
 Justin Hust
 Simon Doty
 Ethan Petuchowski

 Group Project 1A
 LispParser - Lisp Parser and Interpreter 
*******************************************************************************/
options {
             
               
                          
  STATIC=false;
}

PARSER_BEGIN(LispParser)

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.Scanner;


public class LispParser/*@bgen(jjtree)*/implements LispParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTLispParserState jjtree = new JJTLispParserState();

/*@egen*/
  public static void main(String args[]) {
    System.out.println("Welcome to Lisp Parser. Type commands or quit.");

    boolean bQuit = false;
    
    do {
      System.out.print("> ");      
      
      // read a line of input
      String sInput = "";
      Scanner scanIn = new Scanner(System.in);
      sInput = scanIn.nextLine();
      
      if(sInput.equals("quit"))
        bQuit = true;

      else if(sInput.equals("test")) {
        RunTests(); 
     
      } else {                    
        RunCommand(sInput);
                   
      }
              
    } while(!bQuit);

    System.out.println("Parse Completed Successfully.");     
      
  }
  
  // *************************************************************************
  public static void RunCommand(String sCommand_) {
    try {
  
      // build ast from stream created from the input command
      InputStream in = new ByteArrayInputStream(sCommand_.getBytes());          
      LispParser p = new LispParser(in);        
      ASTProgram root = p.Program();
      
      // print the AST
      LispParserVisitor v = new LispParserDumpVisitor();
      root.jjtAccept(v, null);
      
      System.out.println("----------------------");
      
      // interpret the AST
      LispParserVisitor i = new LispParserInterpreterVisitor();
      System.out.println("Interpreted Result: " + root.jjtAccept(i, null) );    

      
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
    
  }
  
  // **************************************************************************
  public static void RunTests() {
    System.out.println("**************** test 1: 5 **************************");
    RunCommand("5");
    System.out.println("**************** test 2: (+ 3 4 5) **************************");    
    RunCommand("(+ 3 4 5)");
    System.out.println("**************** test 3: (- 3 1) **************************");        
    RunCommand("(- 3 1)");
    System.out.println("**************** test 4: (* 7 9) **************************");              
    RunCommand("(* 7 9)");
    System.out.println("**************** test 5: (+ 3 4 (* 7 (- 4 2))) **************************");                  
    RunCommand("(+ 3 4 (* 7 (- 4 2)))");
    System.out.println("**************** test 6: (lambda (y) (+ 3 (- 4 3))) **************************");                  
    RunCommand("(lambda (y) (+ 3 (- 4 3)))");

  }
  
}

PARSER_END(LispParser)

// ***************************************************************************
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

// ***************************************************************************
TOKEN:
{
    < LAMBDA : "lambda" >
  | < LET    : "let" >
  | < LPAR   : "(" >
  | < RPAR   : ")" >
  | < SEMI   : ";" >
  | < OP: ["+", "-", "*", "/"] >
  | < DIGIT : ["0"-"9"] >
  | < LETTER        :  (["a"-"z", "A"-"Z"])+ >
  | < UNDERSCORE    :  ["_"] >      
  | < SYMBOL        :  ["a"-"z", "A"-"Z", "~", "`", "!", "@", "#", "$", "/", "^", "&",
                        "*", "_", "-", "=", "+", "{", "}", "[", "]", "|", "\\", ":",
                        ";", "<", ">", ",", ".", "?", "'", "\""] >

}

// ***************************************************************************
TOKEN : /* LITERALS */
{
  < INTEGER         :  <DIGIT> (<DIGIT>)* >
  | < IDENTIFIER    :  <LETTER> (<DIGIT> | <LETTER> | <UNDERSCORE>)* >  
  
}

// ***************************************************************************
TOKEN:
{
  < ERROR : ~[] >
}

// ***************************************************************************
// program entry point
ASTProgram Program() : {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
try {
/*@egen*/

(  Num()
   | (   LOOKAHEAD(2) LambdaExpr() | ArithExpr() | FunctionExpr()
     )
)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
      
  { return jjtn000; }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
  
}

// ***************************************************************************
/*
void SExpr():
{ }
{
  (Num() | Identifier() | ArithExpr() | LambdaExpr() | FuncApp() | LetExpr())
  
}
*/

// ***************************************************************************
/*
void Body():
{}
{
LOOKAHEAD(2)
 <LPAR> <LPAR>
        Lambda()
 | Expr()
 | Num()
}

*/

// ***************************************************************************
void FunctionExpr() :
{/*@bgen(jjtree) FunctionExpr */
  ASTFunctionExpr jjtn000 = new ASTFunctionExpr(JJTFUNCTIONEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionExpr */
 try {
/*@egen*/
 <LPAR> LambdaExpr()

(  Num()
  | ( LOOKAHEAD(2) LambdaExpr() | ArithExpr() | FunctionExpr() | Identifier()
    )
  
)
    <RPAR>/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}


// ***************************************************************************
void LambdaExpr() :
{/*@bgen(jjtree) LambdaExpr */
  ASTLambdaExpr jjtn000 = new ASTLambdaExpr(JJTLAMBDAEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LambdaExpr */
 try {
/*@egen*/
 <LPAR> 
    <LAMBDA>

    <LPAR>
    Identifier()
    <RPAR>

(  Num()
  | ( LOOKAHEAD(2) LambdaExpr() | ArithExpr() | FunctionExpr() | Identifier()
    )

)

    <RPAR>/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// ***************************************************************************
void ArithExpr(): {/*@bgen(jjtree) ArithExpr */
                    ASTArithExpr jjtn000 = new ASTArithExpr(JJTARITHEXPR);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; String s; }
{/*@bgen(jjtree) ArithExpr */
try {
/*@egen*/
<LPAR> 
	t = <OP>{ s = t.image; jjtn000.setOp(s); }
      (Num() | ArithExpr() )+
   
  <RPAR>/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/

}

// ***************************************************************************
void Identifier(): 
{/*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Identifier */
  try {
/*@egen*/
  t = <LETTER>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ { jjtn000.setIdentifier(t.image); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

// ***************************************************************************
void Num(): 
{/*@bgen(jjtree) Num */
  ASTNum jjtn000 = new ASTNum(JJTNUM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Num */
  try {
/*@egen*/
  t = <DIGIT>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ { jjtn000.setVal(Integer.parseInt(t.image)); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}
